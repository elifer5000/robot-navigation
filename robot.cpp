// Class automatically generated by Dev-C++ New Class wizard

#include "robot.h" // class's header file

// class constructor
robot::robot(float _dx, float _dy, float _theta):
dx(_dx), dy(_dy), theta(_theta), Slice(0) {
	SetDiscretePos();
	Collision=false;
	pGrid=NULL;
}
// class destructor
robot::~robot()
{
}

void robot::AddVertex(float x, float y)
{
    point temp(x,y);
    Vertices.push_back(temp);
}

void robot::CalculateNormals()
{
    int NumVerts=Vertices.size();
    float Min=10;
    int Ind=0;
    
    for (int i=0; i<NumVerts-1; ++i)
    {
        point temp;
        temp=Vertices[i+1]-Vertices[i];
        temp.Normalize();
        float xtemp=temp.x;
        temp.x=-temp.y;
        temp.y=xtemp;
        Normals.push_back(temp);
				RotNormals.push_back(temp);
        RotNormAngles.push_back(temp.GetAngle());
        if (RotNormAngles.back()<Min)
        {
           Min=RotNormAngles.back();
           Ind=RotNormAngles.size()-1;
        }
    }
    point temp;
    temp=Vertices[0]-Vertices[NumVerts-1];
    temp.Normalize();
    float xtemp=temp.x;
    temp.x=-temp.y;
    temp.y=xtemp;
    Normals.push_back(temp);
		RotNormals.push_back(temp);
    RotNormAngles.push_back(temp.GetAngle());
    if (RotNormAngles.back()<Min)
    {
       Min=RotNormAngles.back();
       Ind=RotNormAngles.size()-1;
    }
    MinNormAngInd=Ind;
}

void robot::CalculateVectors()
{
     int NumVerts=Vertices.size();
    
    for (int i=0; i<NumVerts; ++i)
    {
        point temp;
        temp=Vertices[i]-Center;
        Vectors.push_back(temp);
		RotVectors.push_back(temp);
    }
}

void robot::RotateNormals(float Orient)
{
     // Use degrees or set Rotate(Orient,false)
     int NumNorms=Normals.size();
     float Min=10;
     int Ind=MinNormAngInd;
    
    for (int i=0; i<NumNorms; ++i)
    {
        RotNormals.at(i)=Normals.at(i);
        RotNormals.at(i).Rotate(Orient);
        RotNormAngles.at(i)=RotNormals.at(i).GetAngle();
        
        if (RotNormAngles.at(i)<Min)
        {
           Min=RotNormAngles.at(i);
           Ind=i;
        }
    }
    MinNormAngInd=Ind;
}

void robot::RotateVectors(float Orient)
{
     // Use degrees or set Rotate(Orient,false)
     int NumVectors=Vectors.size();
    
    for (int i=0; i<NumVectors; ++i)
    {
        RotVectors.at(i)=Vectors.at(i);
        RotVectors.at(i).Rotate(Orient);
    }
}
    
void robot::Draw()
{
     int NumVerts=Vertices.size();
     
     glPushMatrix();
         glTranslatef(dx,dy,0);
         glRotatef(theta,0,0,1);
		 
         glColor3f(1,0,0);
         glBegin(GL_POLYGON);
            for (int i=0; i<NumVerts; ++i)
            {
                glVertex2f(Vertices[i].x,Vertices[i].y);
            }
         glEnd();

         glColor3f(0,0,0);
         glLineWidth(2);
         glBegin(GL_LINE_LOOP);
            for (int i=0; i<NumVerts; ++i)
            {
                glVertex2f(Vertices[i].x,Vertices[i].y);
            }
         glEnd();
     glPopMatrix();
}

void robot::DrawDiscrete()
{
	int NumVerts=Vertices.size();
     
	glPushMatrix();
	 
	float Step = 1.0f/Resolution;
	float Offset = 0.0*Step;
	point Origin(GridX,GridY);
	Origin.factor(Step);
	glColor3f(1,0.0,0.0);
	glBegin(GL_POLYGON);
	glVertex2f(Origin.x-Step/2.+Offset, Origin.y-Step/2.+Offset);//, 0.5);
	glVertex2f(Origin.x+Step/2.-Offset, Origin.y-Step/2.+Offset);//, 0.5);
	glVertex2f(Origin.x+Step/2.-Offset, Origin.y+Step/2.-Offset);//, 0.5);
	glVertex2f(Origin.x-Step/2.+Offset, Origin.y+Step/2.-Offset);//, 0.5);
	glEnd();
	glColor3f(0.0,0.0,0.0);
	glBegin(GL_LINE_LOOP);
	glVertex2f(Origin.x-Step/2.+Offset, Origin.y-Step/2.+Offset);//, 0.5);
	glVertex2f(Origin.x+Step/2.-Offset, Origin.y-Step/2.+Offset);//, 0.5);
	glVertex2f(Origin.x+Step/2.-Offset, Origin.y+Step/2.-Offset);//, 0.5);
	glVertex2f(Origin.x-Step/2.+Offset, Origin.y+Step/2.-Offset);//, 0.5);
	glEnd();

	glTranslatef(dx,dy,0);
	glRotatef(theta,0,0,1);
		 
	/*glColor4f(1,0.8,0.8,.6);
	glBegin(GL_POLYGON);
	for (int i=0; i<NumVerts; ++i)
	{
		glVertex2f(Vertices[i].x,Vertices[i].y);
	}
	glEnd();*/
		 
	glColor3f(0,0,0);
	glLineWidth(2);
	glBegin(GL_LINE_LOOP);
	for (int i=0; i<NumVerts; ++i)
	{
		glVertex2f(Vertices[i].x,Vertices[i].y);
	}
	glEnd();
	glPopMatrix();
}

void robot::MoveForward()
{
	float Step = 1.0f/Resolution;
	float Diffx=Step*cos(DEG2RAD(theta));
	float Diffy=Step*sin(DEG2RAD(theta));

	if (Collision)
		if (!isFreeSpace(dx+Diffx,dy+Diffy,Slice))
			return;

	dx+=Diffx;
	dy+=Diffy;
	SetDiscretePos();
}

void robot::MoveBack()
{
	float Step = 1.0f/Resolution;
	float Diffx=-Step*cos(DEG2RAD(theta));
	float Diffy=-Step*sin(DEG2RAD(theta));

	if (Collision)
		if (!isFreeSpace(dx+Diffx,dy+Diffy,Slice))
			return;

	dx+=Diffx;
	dy+=Diffy;
	SetDiscretePos();
}


void robot::TurnLeft()
{
	if (Collision)
	{
		if (Slice>=ThetaSections)
		{
			if (!isFreeSpace(dx,dy,0))
			return;
		}
		else
			if (!isFreeSpace(dx,dy,Slice+1))
			return;
	}

	++Slice;
	if (Slice>=ThetaSections) Slice=0;
	theta=(float)Slice/(float)ThetaSections*360.0;
}

void robot::TurnRight()
{
	if (Collision)
	{
		if (Slice==0)
		{
			if (!isFreeSpace(dx,dy,ThetaSections-1))
			return;
		}
		else
			if (!isFreeSpace(dx,dy,Slice-1))
			return;
	}

	--Slice;
	if (Slice<0) Slice=ThetaSections-1;
	theta=(float)Slice/(float)ThetaSections*360.0;
}

void robot::MoveLeft()
{
	float Step = 1.0f/Resolution;
	float Diffx=-Step*sin(DEG2RAD(theta));
	float Diffy=Step*cos(DEG2RAD(theta));

	if (Collision)
		if (!isFreeSpace(dx+Diffx,dy+Diffy,Slice))
			return;

	dx+=Diffx;
	dy+=Diffy;
	SetDiscretePos();
}

void robot::MoveRight()
{
	float Step = 1.0f/Resolution;
	float Diffx=Step*sin(DEG2RAD(theta));
	float Diffy=-Step*cos(DEG2RAD(theta));

	if (Collision)
		if (!isFreeSpace(dx+Diffx,dy+Diffy,Slice))
			return;

	dx+=Diffx;
	dy+=Diffy;
	SetDiscretePos();
}

bool robot::isFreeSpace(float x, float y, int theta)
{
	float Step = 1.0f/Resolution;
	float Offset = 0.0*Step;
	point Origin(x*Resolution,y*Resolution);
	Origin.Round();
	if (pGrid->DiscreteGrid[(int)Origin.x][(int)Origin.y][theta]==1 || pGrid->DiscreteGrid[(int)Origin.x][(int)Origin.y][theta]==2)
		return false;
	else return true;
}

void robot::ToggleCollision()
{
	if (Collision==false)
	{
		if (GridX<0) GridX=0;
		if (GridX>=GridSize) GridX=GridSize-1;
		if (GridY<0) GridY=0;
		if (GridY>=GridSize) GridY=GridSize-1;
		SetPos();
		Collision=true;
	}
	else
		Collision=false;
}

void robot::SetDiscretePos()
{
	float Step = 1.0f/Resolution;
	float Offset = 0.0*Step;
	point Origin(dx*Resolution,dy*Resolution);
	Origin.Round();
	GridX=(int)Origin.x;
	GridY=(int)Origin.y;
}

void robot::SetPos()
{
	point Origin((float)GridX/Resolution,(float)GridY/Resolution);
	dx=Origin.x;
	dy=Origin.y;
}

void robot::SetGrid(CGrid* _pGrid)
{
	pGrid=_pGrid;
	Collision=true;
}

         
     
